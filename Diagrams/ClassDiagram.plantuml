@startuml CPU Simulator

Boostrapper o-- CPU
Boostrapper *-- Clock
Boostrapper *-right- MainView
Boostrapper *-left- Compiler

Clock *-- ClockTransition
Clock *-left- ScheduledExecutorService

CPU *-- SynchrounousComponent
CPU *-- InstructionFetch
CPU *-- InstructionDecode
CPU *-right- ExecutionUnit
CPU *-- Memory
CPU *-left- Clock
CPU *-- Register

Register .up.|> SynchrounousComponent

ExecutionUnit *-up- AluResult

InstructionDecode *-left- ControlSignals 

SynchrounousComponent <|.. InstructionDecode
SynchrounousComponent <|.right. InstructionFetch
SynchrounousComponent <|.left. Memory



enum ClockTransition{
    RISING_EDGE
    FALLING_EDGE
}

class AluResult{
    + res : Int32
    + zero : Boolean
}

class ControlSignals {
    + jump : bool
    + memToReg : bool
    + regWrite : bool
    + memWrite : bool
    + branch : bool
    + aluSrc : bool
    + regDst : bool
    + aluOp : byte
}

interface SynchrounousComponent {
    + executeOnRisingEdge()
    + executeOnFallingEdge()
}

class Boostrapper {
    - cpu : CPU
    - clock : Clock
    - mainView : MainView
}

class CPU {
    - synchronousComponents : List<SynchrounousComponent>
    - clock : Clock
    + reset()
}

class Clock {
    - value : Boolean
    - clockTransition : ClockTransition
    - clockCycleDuration : Integer
    - isAutoTickEnabled : AtomicBoolean
    - scheduler : ScheduledExecutorService
    - onRisingEdge : List<Runnable>
    - onFallingEdge : List<Runnable>
    - tick() : void
    + addOnRisignEdgeCallback(callback: Runnable) : void
    + addOnFallingEdgeCallback(callback: Runnable) : void
    + startAutoTick() : void
    + stopAutoTick() : void
    + TickOnce() : void
}

class Memory {
    - memoryBlock : Vector<Int32>
}

class InstructionFetch {
    - instructionMemory : Vector<Int32>
    - programCounter : Int32
    + getInstruction(adr: Int32): Int32
    + incrementPC(): void
    + jumpToAddress(adr: Int32): void;
}

class InstructionDecode {
    - registerFile : Vector<Int32>
    + readData1(addr1: Int8) : Int32
    + readData2(addr2: Int8) : Int32
    + writeData(writeAddr: Int8, data: Int32): void
    + getControlSignals(instruction: Int32): ControlSignals
    + extendOp(op: Int16, withSign: bool): Int32
}

class ExecutionUnit {
    - getAluControlSignals(TBD: aluOP) : TBD
    + executeInstruction(opA: Int32, opB: Int32, aluOP: TBD) : AluRes
    + getBranchAddress(currPCAddr: Int32, instrToJump: Int32) : Int32
}

class Memory {
    + getData(adr: Int32): Int32
    + writeData(adr: Int32): void
}

class Register {
    - fieldValues : Map<String, Pair<Class, Object>>
    - pendingValues : Map<String, Pair<Class, Object>>
    + addField<T>(fieldName: String) : void
    + setValue<T>(fieldName: String, value: T) : void
    + getValue<T>(fieldName: String) : T
    + executeOnRisignEdge()
    + executeOnFallingEdge()
}

class MainView {
    
}

class Compiler {
    - registerSet : Map<String, Int>
    + compile(program: String) : List<Int32>
}

@enduml